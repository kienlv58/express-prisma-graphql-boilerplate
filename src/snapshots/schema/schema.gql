# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateAuthor {
  _avg: AuthorAvgAggregate
  _count: AuthorCountAggregate
  _max: AuthorMaxAggregate
  _min: AuthorMinAggregate
  _sum: AuthorSumAggregate
}

type AggregateBook {
  _avg: BookAvgAggregate
  _count: BookCountAggregate
  _max: BookMaxAggregate
  _min: BookMinAggregate
  _sum: BookSumAggregate
}

type AggregateCategoriesOnBooks {
  _avg: CategoriesOnBooksAvgAggregate
  _count: CategoriesOnBooksCountAggregate
  _max: CategoriesOnBooksMaxAggregate
  _min: CategoriesOnBooksMinAggregate
  _sum: CategoriesOnBooksSumAggregate
}

type AggregateCategory {
  _avg: CategoryAvgAggregate
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
  _sum: CategorySumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

type Author {
  _count: AuthorCount
  book(cursor: BookWhereUniqueInput, distinct: [BookScalarFieldEnum!], orderBy: [BookOrderByWithRelationInput!], skip: Int, take: Int, where: BookWhereInput): [Book!]!
  created_at: DateTime
  id: Int!
  name: String!
  updated_at: DateTime
}

type AuthorAvgAggregate {
  id: Float
}

input AuthorAvgOrderByAggregateInput {
  id: SortOrder
}

type AuthorCount {
  book: Int!
}

type AuthorCountAggregate {
  _all: Int!
  created_at: Int!
  id: Int!
  name: Int!
  updated_at: Int!
}

input AuthorCountOrderByAggregateInput {
  created_at: SortOrder
  id: SortOrder
  name: SortOrder
  updated_at: SortOrder
}

input AuthorCreateInput {
  book: BookCreateNestedManyWithoutAuthorInput
  created_at: DateTime
  name: String!
  updated_at: DateTime
}

input AuthorCreateManyInput {
  created_at: DateTime
  id: Int
  name: String!
  updated_at: DateTime
}

input AuthorCreateNestedOneWithoutBookInput {
  connect: AuthorWhereUniqueInput
  connectOrCreate: AuthorCreateOrConnectWithoutBookInput
  create: AuthorCreateWithoutBookInput
}

input AuthorCreateOrConnectWithoutBookInput {
  create: AuthorCreateWithoutBookInput!
  where: AuthorWhereUniqueInput!
}

input AuthorCreateWithoutBookInput {
  created_at: DateTime
  name: String!
  updated_at: DateTime
}

type AuthorGroupBy {
  _avg: AuthorAvgAggregate
  _count: AuthorCountAggregate
  _max: AuthorMaxAggregate
  _min: AuthorMinAggregate
  _sum: AuthorSumAggregate
  created_at: DateTime
  id: Int!
  name: String!
  updated_at: DateTime
}

type AuthorMaxAggregate {
  created_at: DateTime
  id: Int
  name: String
  updated_at: DateTime
}

input AuthorMaxOrderByAggregateInput {
  created_at: SortOrder
  id: SortOrder
  name: SortOrder
  updated_at: SortOrder
}

type AuthorMinAggregate {
  created_at: DateTime
  id: Int
  name: String
  updated_at: DateTime
}

input AuthorMinOrderByAggregateInput {
  created_at: SortOrder
  id: SortOrder
  name: SortOrder
  updated_at: SortOrder
}

input AuthorOrderByWithAggregationInput {
  _avg: AuthorAvgOrderByAggregateInput
  _count: AuthorCountOrderByAggregateInput
  _max: AuthorMaxOrderByAggregateInput
  _min: AuthorMinOrderByAggregateInput
  _sum: AuthorSumOrderByAggregateInput
  created_at: SortOrder
  id: SortOrder
  name: SortOrder
  updated_at: SortOrder
}

input AuthorOrderByWithRelationInput {
  book: BookOrderByRelationAggregateInput
  created_at: SortOrder
  id: SortOrder
  name: SortOrder
  updated_at: SortOrder
}

input AuthorRelationFilter {
  is: AuthorWhereInput
  isNot: AuthorWhereInput
}

enum AuthorScalarFieldEnum {
  created_at
  id
  name
  updated_at
}

input AuthorScalarWhereWithAggregatesInput {
  AND: [AuthorScalarWhereWithAggregatesInput!]
  NOT: [AuthorScalarWhereWithAggregatesInput!]
  OR: [AuthorScalarWhereWithAggregatesInput!]
  created_at: DateTimeNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  updated_at: DateTimeNullableWithAggregatesFilter
}

type AuthorSumAggregate {
  id: Int
}

input AuthorSumOrderByAggregateInput {
  id: SortOrder
}

input AuthorUpdateInput {
  book: BookUpdateManyWithoutAuthorNestedInput
  created_at: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
}

input AuthorUpdateManyMutationInput {
  created_at: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
}

input AuthorUpdateOneWithoutBookNestedInput {
  connect: AuthorWhereUniqueInput
  connectOrCreate: AuthorCreateOrConnectWithoutBookInput
  create: AuthorCreateWithoutBookInput
  delete: Boolean
  disconnect: Boolean
  update: AuthorUpdateWithoutBookInput
  upsert: AuthorUpsertWithoutBookInput
}

input AuthorUpdateWithoutBookInput {
  created_at: NullableDateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
}

input AuthorUpsertWithoutBookInput {
  create: AuthorCreateWithoutBookInput!
  update: AuthorUpdateWithoutBookInput!
}

input AuthorWhereInput {
  AND: [AuthorWhereInput!]
  NOT: [AuthorWhereInput!]
  OR: [AuthorWhereInput!]
  book: BookListRelationFilter
  created_at: DateTimeNullableFilter
  id: IntFilter
  name: StringFilter
  updated_at: DateTimeNullableFilter
}

input AuthorWhereUniqueInput {
  id: Int
  name: String
}

type Book {
  _count: BookCount
  author: Author
  authorId: Int
  categories(cursor: CategoriesOnBooksWhereUniqueInput, distinct: [CategoriesOnBooksScalarFieldEnum!], orderBy: [CategoriesOnBooksOrderByWithRelationInput!], skip: Int, take: Int, where: CategoriesOnBooksWhereInput): [CategoriesOnBooks!]!
  created_at: DateTime
  description: String!
  id: Int!
  imageThumbnail: String!
  isDeleted: Boolean!
  isPublished: Boolean!
  languageName: String!
  published_at: DateTime
  title: String!
  updated_at: DateTime
}

type BookAvgAggregate {
  authorId: Float
  id: Float
}

input BookAvgOrderByAggregateInput {
  authorId: SortOrder
  id: SortOrder
}

type BookCount {
  categories: Int!
}

type BookCountAggregate {
  _all: Int!
  authorId: Int!
  created_at: Int!
  description: Int!
  id: Int!
  imageThumbnail: Int!
  isDeleted: Int!
  isPublished: Int!
  languageName: Int!
  published_at: Int!
  title: Int!
  updated_at: Int!
}

input BookCountOrderByAggregateInput {
  authorId: SortOrder
  created_at: SortOrder
  description: SortOrder
  id: SortOrder
  imageThumbnail: SortOrder
  isDeleted: SortOrder
  isPublished: SortOrder
  languageName: SortOrder
  published_at: SortOrder
  title: SortOrder
  updated_at: SortOrder
}

input BookCreateInput {
  author: AuthorCreateNestedOneWithoutBookInput
  categories: CategoriesOnBooksCreateNestedManyWithoutBookInput
  created_at: DateTime
  description: String!
  imageThumbnail: String!
  isDeleted: Boolean
  isPublished: Boolean
  languageName: String!
  published_at: DateTime
  title: String!
  updated_at: DateTime
}

input BookCreateManyAuthorInput {
  created_at: DateTime
  description: String!
  id: Int
  imageThumbnail: String!
  isDeleted: Boolean
  isPublished: Boolean
  languageName: String!
  published_at: DateTime
  title: String!
  updated_at: DateTime
}

input BookCreateManyAuthorInputEnvelope {
  data: [BookCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input BookCreateManyInput {
  authorId: Int
  created_at: DateTime
  description: String!
  id: Int
  imageThumbnail: String!
  isDeleted: Boolean
  isPublished: Boolean
  languageName: String!
  published_at: DateTime
  title: String!
  updated_at: DateTime
}

input BookCreateNestedManyWithoutAuthorInput {
  connect: [BookWhereUniqueInput!]
  connectOrCreate: [BookCreateOrConnectWithoutAuthorInput!]
  create: [BookCreateWithoutAuthorInput!]
  createMany: BookCreateManyAuthorInputEnvelope
}

input BookCreateNestedOneWithoutCategoriesInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutCategoriesInput
  create: BookCreateWithoutCategoriesInput
}

input BookCreateOrConnectWithoutAuthorInput {
  create: BookCreateWithoutAuthorInput!
  where: BookWhereUniqueInput!
}

input BookCreateOrConnectWithoutCategoriesInput {
  create: BookCreateWithoutCategoriesInput!
  where: BookWhereUniqueInput!
}

input BookCreateWithoutAuthorInput {
  categories: CategoriesOnBooksCreateNestedManyWithoutBookInput
  created_at: DateTime
  description: String!
  imageThumbnail: String!
  isDeleted: Boolean
  isPublished: Boolean
  languageName: String!
  published_at: DateTime
  title: String!
  updated_at: DateTime
}

input BookCreateWithoutCategoriesInput {
  author: AuthorCreateNestedOneWithoutBookInput
  created_at: DateTime
  description: String!
  imageThumbnail: String!
  isDeleted: Boolean
  isPublished: Boolean
  languageName: String!
  published_at: DateTime
  title: String!
  updated_at: DateTime
}

type BookGroupBy {
  _avg: BookAvgAggregate
  _count: BookCountAggregate
  _max: BookMaxAggregate
  _min: BookMinAggregate
  _sum: BookSumAggregate
  authorId: Int
  created_at: DateTime
  description: String!
  id: Int!
  imageThumbnail: String!
  isDeleted: Boolean!
  isPublished: Boolean!
  languageName: String!
  published_at: DateTime
  title: String!
  updated_at: DateTime
}

input BookListRelationFilter {
  every: BookWhereInput
  none: BookWhereInput
  some: BookWhereInput
}

type BookMaxAggregate {
  authorId: Int
  created_at: DateTime
  description: String
  id: Int
  imageThumbnail: String
  isDeleted: Boolean
  isPublished: Boolean
  languageName: String
  published_at: DateTime
  title: String
  updated_at: DateTime
}

input BookMaxOrderByAggregateInput {
  authorId: SortOrder
  created_at: SortOrder
  description: SortOrder
  id: SortOrder
  imageThumbnail: SortOrder
  isDeleted: SortOrder
  isPublished: SortOrder
  languageName: SortOrder
  published_at: SortOrder
  title: SortOrder
  updated_at: SortOrder
}

type BookMinAggregate {
  authorId: Int
  created_at: DateTime
  description: String
  id: Int
  imageThumbnail: String
  isDeleted: Boolean
  isPublished: Boolean
  languageName: String
  published_at: DateTime
  title: String
  updated_at: DateTime
}

input BookMinOrderByAggregateInput {
  authorId: SortOrder
  created_at: SortOrder
  description: SortOrder
  id: SortOrder
  imageThumbnail: SortOrder
  isDeleted: SortOrder
  isPublished: SortOrder
  languageName: SortOrder
  published_at: SortOrder
  title: SortOrder
  updated_at: SortOrder
}

input BookOrderByRelationAggregateInput {
  _count: SortOrder
}

input BookOrderByWithAggregationInput {
  _avg: BookAvgOrderByAggregateInput
  _count: BookCountOrderByAggregateInput
  _max: BookMaxOrderByAggregateInput
  _min: BookMinOrderByAggregateInput
  _sum: BookSumOrderByAggregateInput
  authorId: SortOrder
  created_at: SortOrder
  description: SortOrder
  id: SortOrder
  imageThumbnail: SortOrder
  isDeleted: SortOrder
  isPublished: SortOrder
  languageName: SortOrder
  published_at: SortOrder
  title: SortOrder
  updated_at: SortOrder
}

input BookOrderByWithRelationInput {
  author: AuthorOrderByWithRelationInput
  authorId: SortOrder
  categories: CategoriesOnBooksOrderByRelationAggregateInput
  created_at: SortOrder
  description: SortOrder
  id: SortOrder
  imageThumbnail: SortOrder
  isDeleted: SortOrder
  isPublished: SortOrder
  languageName: SortOrder
  published_at: SortOrder
  title: SortOrder
  updated_at: SortOrder
}

input BookRelationFilter {
  is: BookWhereInput
  isNot: BookWhereInput
}

enum BookScalarFieldEnum {
  authorId
  created_at
  description
  id
  imageThumbnail
  isDeleted
  isPublished
  languageName
  published_at
  title
  updated_at
}

input BookScalarWhereInput {
  AND: [BookScalarWhereInput!]
  NOT: [BookScalarWhereInput!]
  OR: [BookScalarWhereInput!]
  authorId: IntNullableFilter
  created_at: DateTimeNullableFilter
  description: StringFilter
  id: IntFilter
  imageThumbnail: StringFilter
  isDeleted: BoolFilter
  isPublished: BoolFilter
  languageName: StringFilter
  published_at: DateTimeNullableFilter
  title: StringFilter
  updated_at: DateTimeNullableFilter
}

input BookScalarWhereWithAggregatesInput {
  AND: [BookScalarWhereWithAggregatesInput!]
  NOT: [BookScalarWhereWithAggregatesInput!]
  OR: [BookScalarWhereWithAggregatesInput!]
  authorId: IntNullableWithAggregatesFilter
  created_at: DateTimeNullableWithAggregatesFilter
  description: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  imageThumbnail: StringWithAggregatesFilter
  isDeleted: BoolWithAggregatesFilter
  isPublished: BoolWithAggregatesFilter
  languageName: StringWithAggregatesFilter
  published_at: DateTimeNullableWithAggregatesFilter
  title: StringWithAggregatesFilter
  updated_at: DateTimeNullableWithAggregatesFilter
}

type BookSumAggregate {
  authorId: Int
  id: Int
}

input BookSumOrderByAggregateInput {
  authorId: SortOrder
  id: SortOrder
}

input BookUpdateInput {
  author: AuthorUpdateOneWithoutBookNestedInput
  categories: CategoriesOnBooksUpdateManyWithoutBookNestedInput
  created_at: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  imageThumbnail: StringFieldUpdateOperationsInput
  isDeleted: BoolFieldUpdateOperationsInput
  isPublished: BoolFieldUpdateOperationsInput
  languageName: StringFieldUpdateOperationsInput
  published_at: NullableDateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
}

input BookUpdateManyMutationInput {
  created_at: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  imageThumbnail: StringFieldUpdateOperationsInput
  isDeleted: BoolFieldUpdateOperationsInput
  isPublished: BoolFieldUpdateOperationsInput
  languageName: StringFieldUpdateOperationsInput
  published_at: NullableDateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
}

input BookUpdateManyWithWhereWithoutAuthorInput {
  data: BookUpdateManyMutationInput!
  where: BookScalarWhereInput!
}

input BookUpdateManyWithoutAuthorNestedInput {
  connect: [BookWhereUniqueInput!]
  connectOrCreate: [BookCreateOrConnectWithoutAuthorInput!]
  create: [BookCreateWithoutAuthorInput!]
  createMany: BookCreateManyAuthorInputEnvelope
  delete: [BookWhereUniqueInput!]
  deleteMany: [BookScalarWhereInput!]
  disconnect: [BookWhereUniqueInput!]
  set: [BookWhereUniqueInput!]
  update: [BookUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [BookUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [BookUpsertWithWhereUniqueWithoutAuthorInput!]
}

input BookUpdateOneRequiredWithoutCategoriesNestedInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutCategoriesInput
  create: BookCreateWithoutCategoriesInput
  update: BookUpdateWithoutCategoriesInput
  upsert: BookUpsertWithoutCategoriesInput
}

input BookUpdateWithWhereUniqueWithoutAuthorInput {
  data: BookUpdateWithoutAuthorInput!
  where: BookWhereUniqueInput!
}

input BookUpdateWithoutAuthorInput {
  categories: CategoriesOnBooksUpdateManyWithoutBookNestedInput
  created_at: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  imageThumbnail: StringFieldUpdateOperationsInput
  isDeleted: BoolFieldUpdateOperationsInput
  isPublished: BoolFieldUpdateOperationsInput
  languageName: StringFieldUpdateOperationsInput
  published_at: NullableDateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
}

input BookUpdateWithoutCategoriesInput {
  author: AuthorUpdateOneWithoutBookNestedInput
  created_at: NullableDateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  imageThumbnail: StringFieldUpdateOperationsInput
  isDeleted: BoolFieldUpdateOperationsInput
  isPublished: BoolFieldUpdateOperationsInput
  languageName: StringFieldUpdateOperationsInput
  published_at: NullableDateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
}

input BookUpsertWithWhereUniqueWithoutAuthorInput {
  create: BookCreateWithoutAuthorInput!
  update: BookUpdateWithoutAuthorInput!
  where: BookWhereUniqueInput!
}

input BookUpsertWithoutCategoriesInput {
  create: BookCreateWithoutCategoriesInput!
  update: BookUpdateWithoutCategoriesInput!
}

input BookWhereInput {
  AND: [BookWhereInput!]
  NOT: [BookWhereInput!]
  OR: [BookWhereInput!]
  author: AuthorRelationFilter
  authorId: IntNullableFilter
  categories: CategoriesOnBooksListRelationFilter
  created_at: DateTimeNullableFilter
  description: StringFilter
  id: IntFilter
  imageThumbnail: StringFilter
  isDeleted: BoolFilter
  isPublished: BoolFilter
  languageName: StringFilter
  published_at: DateTimeNullableFilter
  title: StringFilter
  updated_at: DateTimeNullableFilter
}

input BookWhereUniqueInput {
  id: Int
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type CategoriesOnBooks {
  book: Book!
  bookId: Int!
  category: Category!
  categoryId: Int!
  created_at: DateTime
  updated_at: DateTime
}

type CategoriesOnBooksAvgAggregate {
  bookId: Float
  categoryId: Float
}

input CategoriesOnBooksAvgOrderByAggregateInput {
  bookId: SortOrder
  categoryId: SortOrder
}

input CategoriesOnBooksCategoryIdBookIdCompoundUniqueInput {
  bookId: Int!
  categoryId: Int!
}

type CategoriesOnBooksCountAggregate {
  _all: Int!
  bookId: Int!
  categoryId: Int!
  created_at: Int!
  updated_at: Int!
}

input CategoriesOnBooksCountOrderByAggregateInput {
  bookId: SortOrder
  categoryId: SortOrder
  created_at: SortOrder
  updated_at: SortOrder
}

input CategoriesOnBooksCreateInput {
  book: BookCreateNestedOneWithoutCategoriesInput!
  category: CategoryCreateNestedOneWithoutCategoriesOnBooksInput!
  created_at: DateTime
  updated_at: DateTime
}

input CategoriesOnBooksCreateManyBookInput {
  categoryId: Int!
  created_at: DateTime
  updated_at: DateTime
}

input CategoriesOnBooksCreateManyBookInputEnvelope {
  data: [CategoriesOnBooksCreateManyBookInput!]!
  skipDuplicates: Boolean
}

input CategoriesOnBooksCreateManyCategoryInput {
  bookId: Int!
  created_at: DateTime
  updated_at: DateTime
}

input CategoriesOnBooksCreateManyCategoryInputEnvelope {
  data: [CategoriesOnBooksCreateManyCategoryInput!]!
  skipDuplicates: Boolean
}

input CategoriesOnBooksCreateManyInput {
  bookId: Int!
  categoryId: Int!
  created_at: DateTime
  updated_at: DateTime
}

input CategoriesOnBooksCreateNestedManyWithoutBookInput {
  connect: [CategoriesOnBooksWhereUniqueInput!]
  connectOrCreate: [CategoriesOnBooksCreateOrConnectWithoutBookInput!]
  create: [CategoriesOnBooksCreateWithoutBookInput!]
  createMany: CategoriesOnBooksCreateManyBookInputEnvelope
}

input CategoriesOnBooksCreateNestedManyWithoutCategoryInput {
  connect: [CategoriesOnBooksWhereUniqueInput!]
  connectOrCreate: [CategoriesOnBooksCreateOrConnectWithoutCategoryInput!]
  create: [CategoriesOnBooksCreateWithoutCategoryInput!]
  createMany: CategoriesOnBooksCreateManyCategoryInputEnvelope
}

input CategoriesOnBooksCreateOrConnectWithoutBookInput {
  create: CategoriesOnBooksCreateWithoutBookInput!
  where: CategoriesOnBooksWhereUniqueInput!
}

input CategoriesOnBooksCreateOrConnectWithoutCategoryInput {
  create: CategoriesOnBooksCreateWithoutCategoryInput!
  where: CategoriesOnBooksWhereUniqueInput!
}

input CategoriesOnBooksCreateWithoutBookInput {
  category: CategoryCreateNestedOneWithoutCategoriesOnBooksInput!
  created_at: DateTime
  updated_at: DateTime
}

input CategoriesOnBooksCreateWithoutCategoryInput {
  book: BookCreateNestedOneWithoutCategoriesInput!
  created_at: DateTime
  updated_at: DateTime
}

type CategoriesOnBooksGroupBy {
  _avg: CategoriesOnBooksAvgAggregate
  _count: CategoriesOnBooksCountAggregate
  _max: CategoriesOnBooksMaxAggregate
  _min: CategoriesOnBooksMinAggregate
  _sum: CategoriesOnBooksSumAggregate
  bookId: Int!
  categoryId: Int!
  created_at: DateTime
  updated_at: DateTime
}

input CategoriesOnBooksListRelationFilter {
  every: CategoriesOnBooksWhereInput
  none: CategoriesOnBooksWhereInput
  some: CategoriesOnBooksWhereInput
}

type CategoriesOnBooksMaxAggregate {
  bookId: Int
  categoryId: Int
  created_at: DateTime
  updated_at: DateTime
}

input CategoriesOnBooksMaxOrderByAggregateInput {
  bookId: SortOrder
  categoryId: SortOrder
  created_at: SortOrder
  updated_at: SortOrder
}

type CategoriesOnBooksMinAggregate {
  bookId: Int
  categoryId: Int
  created_at: DateTime
  updated_at: DateTime
}

input CategoriesOnBooksMinOrderByAggregateInput {
  bookId: SortOrder
  categoryId: SortOrder
  created_at: SortOrder
  updated_at: SortOrder
}

input CategoriesOnBooksOrderByRelationAggregateInput {
  _count: SortOrder
}

input CategoriesOnBooksOrderByWithAggregationInput {
  _avg: CategoriesOnBooksAvgOrderByAggregateInput
  _count: CategoriesOnBooksCountOrderByAggregateInput
  _max: CategoriesOnBooksMaxOrderByAggregateInput
  _min: CategoriesOnBooksMinOrderByAggregateInput
  _sum: CategoriesOnBooksSumOrderByAggregateInput
  bookId: SortOrder
  categoryId: SortOrder
  created_at: SortOrder
  updated_at: SortOrder
}

input CategoriesOnBooksOrderByWithRelationInput {
  book: BookOrderByWithRelationInput
  bookId: SortOrder
  category: CategoryOrderByWithRelationInput
  categoryId: SortOrder
  created_at: SortOrder
  updated_at: SortOrder
}

enum CategoriesOnBooksScalarFieldEnum {
  bookId
  categoryId
  created_at
  updated_at
}

input CategoriesOnBooksScalarWhereInput {
  AND: [CategoriesOnBooksScalarWhereInput!]
  NOT: [CategoriesOnBooksScalarWhereInput!]
  OR: [CategoriesOnBooksScalarWhereInput!]
  bookId: IntFilter
  categoryId: IntFilter
  created_at: DateTimeNullableFilter
  updated_at: DateTimeNullableFilter
}

input CategoriesOnBooksScalarWhereWithAggregatesInput {
  AND: [CategoriesOnBooksScalarWhereWithAggregatesInput!]
  NOT: [CategoriesOnBooksScalarWhereWithAggregatesInput!]
  OR: [CategoriesOnBooksScalarWhereWithAggregatesInput!]
  bookId: IntWithAggregatesFilter
  categoryId: IntWithAggregatesFilter
  created_at: DateTimeNullableWithAggregatesFilter
  updated_at: DateTimeNullableWithAggregatesFilter
}

type CategoriesOnBooksSumAggregate {
  bookId: Int
  categoryId: Int
}

input CategoriesOnBooksSumOrderByAggregateInput {
  bookId: SortOrder
  categoryId: SortOrder
}

input CategoriesOnBooksUpdateInput {
  book: BookUpdateOneRequiredWithoutCategoriesNestedInput
  category: CategoryUpdateOneRequiredWithoutCategoriesOnBooksNestedInput
  created_at: NullableDateTimeFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
}

input CategoriesOnBooksUpdateManyMutationInput {
  created_at: NullableDateTimeFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
}

input CategoriesOnBooksUpdateManyWithWhereWithoutBookInput {
  data: CategoriesOnBooksUpdateManyMutationInput!
  where: CategoriesOnBooksScalarWhereInput!
}

input CategoriesOnBooksUpdateManyWithWhereWithoutCategoryInput {
  data: CategoriesOnBooksUpdateManyMutationInput!
  where: CategoriesOnBooksScalarWhereInput!
}

input CategoriesOnBooksUpdateManyWithoutBookNestedInput {
  connect: [CategoriesOnBooksWhereUniqueInput!]
  connectOrCreate: [CategoriesOnBooksCreateOrConnectWithoutBookInput!]
  create: [CategoriesOnBooksCreateWithoutBookInput!]
  createMany: CategoriesOnBooksCreateManyBookInputEnvelope
  delete: [CategoriesOnBooksWhereUniqueInput!]
  deleteMany: [CategoriesOnBooksScalarWhereInput!]
  disconnect: [CategoriesOnBooksWhereUniqueInput!]
  set: [CategoriesOnBooksWhereUniqueInput!]
  update: [CategoriesOnBooksUpdateWithWhereUniqueWithoutBookInput!]
  updateMany: [CategoriesOnBooksUpdateManyWithWhereWithoutBookInput!]
  upsert: [CategoriesOnBooksUpsertWithWhereUniqueWithoutBookInput!]
}

input CategoriesOnBooksUpdateManyWithoutCategoryNestedInput {
  connect: [CategoriesOnBooksWhereUniqueInput!]
  connectOrCreate: [CategoriesOnBooksCreateOrConnectWithoutCategoryInput!]
  create: [CategoriesOnBooksCreateWithoutCategoryInput!]
  createMany: CategoriesOnBooksCreateManyCategoryInputEnvelope
  delete: [CategoriesOnBooksWhereUniqueInput!]
  deleteMany: [CategoriesOnBooksScalarWhereInput!]
  disconnect: [CategoriesOnBooksWhereUniqueInput!]
  set: [CategoriesOnBooksWhereUniqueInput!]
  update: [CategoriesOnBooksUpdateWithWhereUniqueWithoutCategoryInput!]
  updateMany: [CategoriesOnBooksUpdateManyWithWhereWithoutCategoryInput!]
  upsert: [CategoriesOnBooksUpsertWithWhereUniqueWithoutCategoryInput!]
}

input CategoriesOnBooksUpdateWithWhereUniqueWithoutBookInput {
  data: CategoriesOnBooksUpdateWithoutBookInput!
  where: CategoriesOnBooksWhereUniqueInput!
}

input CategoriesOnBooksUpdateWithWhereUniqueWithoutCategoryInput {
  data: CategoriesOnBooksUpdateWithoutCategoryInput!
  where: CategoriesOnBooksWhereUniqueInput!
}

input CategoriesOnBooksUpdateWithoutBookInput {
  category: CategoryUpdateOneRequiredWithoutCategoriesOnBooksNestedInput
  created_at: NullableDateTimeFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
}

input CategoriesOnBooksUpdateWithoutCategoryInput {
  book: BookUpdateOneRequiredWithoutCategoriesNestedInput
  created_at: NullableDateTimeFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
}

input CategoriesOnBooksUpsertWithWhereUniqueWithoutBookInput {
  create: CategoriesOnBooksCreateWithoutBookInput!
  update: CategoriesOnBooksUpdateWithoutBookInput!
  where: CategoriesOnBooksWhereUniqueInput!
}

input CategoriesOnBooksUpsertWithWhereUniqueWithoutCategoryInput {
  create: CategoriesOnBooksCreateWithoutCategoryInput!
  update: CategoriesOnBooksUpdateWithoutCategoryInput!
  where: CategoriesOnBooksWhereUniqueInput!
}

input CategoriesOnBooksWhereInput {
  AND: [CategoriesOnBooksWhereInput!]
  NOT: [CategoriesOnBooksWhereInput!]
  OR: [CategoriesOnBooksWhereInput!]
  book: BookRelationFilter
  bookId: IntFilter
  category: CategoryRelationFilter
  categoryId: IntFilter
  created_at: DateTimeNullableFilter
  updated_at: DateTimeNullableFilter
}

input CategoriesOnBooksWhereUniqueInput {
  categoryId_bookId: CategoriesOnBooksCategoryIdBookIdCompoundUniqueInput
}

type Category {
  _count: CategoryCount
  categoriesOnBooks(cursor: CategoriesOnBooksWhereUniqueInput, distinct: [CategoriesOnBooksScalarFieldEnum!], orderBy: [CategoriesOnBooksOrderByWithRelationInput!], skip: Int, take: Int, where: CategoriesOnBooksWhereInput): [CategoriesOnBooks!]!
  created_at: DateTime
  displayName: String!
  id: Int!
  name: String!
  updated_at: DateTime
}

type CategoryAvgAggregate {
  id: Float
}

input CategoryAvgOrderByAggregateInput {
  id: SortOrder
}

type CategoryCount {
  categoriesOnBooks: Int!
}

type CategoryCountAggregate {
  _all: Int!
  created_at: Int!
  displayName: Int!
  id: Int!
  name: Int!
  updated_at: Int!
}

input CategoryCountOrderByAggregateInput {
  created_at: SortOrder
  displayName: SortOrder
  id: SortOrder
  name: SortOrder
  updated_at: SortOrder
}

input CategoryCreateInput {
  categoriesOnBooks: CategoriesOnBooksCreateNestedManyWithoutCategoryInput
  created_at: DateTime
  displayName: String!
  name: String!
  updated_at: DateTime
}

input CategoryCreateManyInput {
  created_at: DateTime
  displayName: String!
  id: Int
  name: String!
  updated_at: DateTime
}

input CategoryCreateNestedOneWithoutCategoriesOnBooksInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutCategoriesOnBooksInput
  create: CategoryCreateWithoutCategoriesOnBooksInput
}

input CategoryCreateOrConnectWithoutCategoriesOnBooksInput {
  create: CategoryCreateWithoutCategoriesOnBooksInput!
  where: CategoryWhereUniqueInput!
}

input CategoryCreateWithoutCategoriesOnBooksInput {
  created_at: DateTime
  displayName: String!
  name: String!
  updated_at: DateTime
}

type CategoryGroupBy {
  _avg: CategoryAvgAggregate
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
  _sum: CategorySumAggregate
  created_at: DateTime
  displayName: String!
  id: Int!
  name: String!
  updated_at: DateTime
}

type CategoryMaxAggregate {
  created_at: DateTime
  displayName: String
  id: Int
  name: String
  updated_at: DateTime
}

input CategoryMaxOrderByAggregateInput {
  created_at: SortOrder
  displayName: SortOrder
  id: SortOrder
  name: SortOrder
  updated_at: SortOrder
}

type CategoryMinAggregate {
  created_at: DateTime
  displayName: String
  id: Int
  name: String
  updated_at: DateTime
}

input CategoryMinOrderByAggregateInput {
  created_at: SortOrder
  displayName: SortOrder
  id: SortOrder
  name: SortOrder
  updated_at: SortOrder
}

input CategoryOrderByWithAggregationInput {
  _avg: CategoryAvgOrderByAggregateInput
  _count: CategoryCountOrderByAggregateInput
  _max: CategoryMaxOrderByAggregateInput
  _min: CategoryMinOrderByAggregateInput
  _sum: CategorySumOrderByAggregateInput
  created_at: SortOrder
  displayName: SortOrder
  id: SortOrder
  name: SortOrder
  updated_at: SortOrder
}

input CategoryOrderByWithRelationInput {
  categoriesOnBooks: CategoriesOnBooksOrderByRelationAggregateInput
  created_at: SortOrder
  displayName: SortOrder
  id: SortOrder
  name: SortOrder
  updated_at: SortOrder
}

input CategoryRelationFilter {
  is: CategoryWhereInput
  isNot: CategoryWhereInput
}

enum CategoryScalarFieldEnum {
  created_at
  displayName
  id
  name
  updated_at
}

input CategoryScalarWhereWithAggregatesInput {
  AND: [CategoryScalarWhereWithAggregatesInput!]
  NOT: [CategoryScalarWhereWithAggregatesInput!]
  OR: [CategoryScalarWhereWithAggregatesInput!]
  created_at: DateTimeNullableWithAggregatesFilter
  displayName: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  updated_at: DateTimeNullableWithAggregatesFilter
}

type CategorySumAggregate {
  id: Int
}

input CategorySumOrderByAggregateInput {
  id: SortOrder
}

input CategoryUpdateInput {
  categoriesOnBooks: CategoriesOnBooksUpdateManyWithoutCategoryNestedInput
  created_at: NullableDateTimeFieldUpdateOperationsInput
  displayName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
}

input CategoryUpdateManyMutationInput {
  created_at: NullableDateTimeFieldUpdateOperationsInput
  displayName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
}

input CategoryUpdateOneRequiredWithoutCategoriesOnBooksNestedInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutCategoriesOnBooksInput
  create: CategoryCreateWithoutCategoriesOnBooksInput
  update: CategoryUpdateWithoutCategoriesOnBooksInput
  upsert: CategoryUpsertWithoutCategoriesOnBooksInput
}

input CategoryUpdateWithoutCategoriesOnBooksInput {
  created_at: NullableDateTimeFieldUpdateOperationsInput
  displayName: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
}

input CategoryUpsertWithoutCategoriesOnBooksInput {
  create: CategoryCreateWithoutCategoriesOnBooksInput!
  update: CategoryUpdateWithoutCategoriesOnBooksInput!
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  categoriesOnBooks: CategoriesOnBooksListRelationFilter
  created_at: DateTimeNullableFilter
  displayName: StringFilter
  id: IntFilter
  name: StringFilter
  updated_at: DateTimeNullableFilter
}

input CategoryWhereUniqueInput {
  id: Int
  name: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createManyAuthor(data: [AuthorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyBook(data: [BookCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCategoriesOnBooks(data: [CategoriesOnBooksCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCategory(data: [CategoryCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneAuthor(data: AuthorCreateInput!): Author!
  createOneBook(data: BookCreateInput!): Book!
  createOneCategoriesOnBooks(data: CategoriesOnBooksCreateInput!): CategoriesOnBooks!
  createOneCategory(data: CategoryCreateInput!): Category!
  createOneUser(data: UserCreateInput!): User!
  deleteManyAuthor(where: AuthorWhereInput): AffectedRowsOutput!
  deleteManyBook(where: BookWhereInput): AffectedRowsOutput!
  deleteManyCategoriesOnBooks(where: CategoriesOnBooksWhereInput): AffectedRowsOutput!
  deleteManyCategory(where: CategoryWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneAuthor(where: AuthorWhereUniqueInput!): Author
  deleteOneBook(where: BookWhereUniqueInput!): Book
  deleteOneCategoriesOnBooks(where: CategoriesOnBooksWhereUniqueInput!): CategoriesOnBooks
  deleteOneCategory(where: CategoryWhereUniqueInput!): Category
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyAuthor(data: AuthorUpdateManyMutationInput!, where: AuthorWhereInput): AffectedRowsOutput!
  updateManyBook(data: BookUpdateManyMutationInput!, where: BookWhereInput): AffectedRowsOutput!
  updateManyCategoriesOnBooks(data: CategoriesOnBooksUpdateManyMutationInput!, where: CategoriesOnBooksWhereInput): AffectedRowsOutput!
  updateManyCategory(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneAuthor(data: AuthorUpdateInput!, where: AuthorWhereUniqueInput!): Author
  updateOneBook(data: BookUpdateInput!, where: BookWhereUniqueInput!): Book
  updateOneCategoriesOnBooks(data: CategoriesOnBooksUpdateInput!, where: CategoriesOnBooksWhereUniqueInput!): CategoriesOnBooks
  updateOneCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneAuthor(create: AuthorCreateInput!, update: AuthorUpdateInput!, where: AuthorWhereUniqueInput!): Author!
  upsertOneBook(create: BookCreateInput!, update: BookUpdateInput!, where: BookWhereUniqueInput!): Book!
  upsertOneCategoriesOnBooks(create: CategoriesOnBooksCreateInput!, update: CategoriesOnBooksUpdateInput!, where: CategoriesOnBooksWhereUniqueInput!): CategoriesOnBooks!
  upsertOneCategory(create: CategoryCreateInput!, update: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

type Query {
  aggregateAuthor(cursor: AuthorWhereUniqueInput, orderBy: [AuthorOrderByWithRelationInput!], skip: Int, take: Int, where: AuthorWhereInput): AggregateAuthor!
  aggregateBook(cursor: BookWhereUniqueInput, orderBy: [BookOrderByWithRelationInput!], skip: Int, take: Int, where: BookWhereInput): AggregateBook!
  aggregateCategoriesOnBooks(cursor: CategoriesOnBooksWhereUniqueInput, orderBy: [CategoriesOnBooksOrderByWithRelationInput!], skip: Int, take: Int, where: CategoriesOnBooksWhereInput): AggregateCategoriesOnBooks!
  aggregateCategory(cursor: CategoryWhereUniqueInput, orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): AggregateCategory!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  author(where: AuthorWhereUniqueInput!): Author
  authors(cursor: AuthorWhereUniqueInput, distinct: [AuthorScalarFieldEnum!], orderBy: [AuthorOrderByWithRelationInput!], skip: Int, take: Int, where: AuthorWhereInput): [Author!]!
  bestUser: User
  book(where: BookWhereUniqueInput!): Book
  books(cursor: BookWhereUniqueInput, distinct: [BookScalarFieldEnum!], orderBy: [BookOrderByWithRelationInput!], skip: Int, take: Int, where: BookWhereInput): [Book!]!
  categories(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  category(where: CategoryWhereUniqueInput!): Category
  findFirstAuthor(cursor: AuthorWhereUniqueInput, distinct: [AuthorScalarFieldEnum!], orderBy: [AuthorOrderByWithRelationInput!], skip: Int, take: Int, where: AuthorWhereInput): Author
  findFirstAuthorOrThrow(cursor: AuthorWhereUniqueInput, distinct: [AuthorScalarFieldEnum!], orderBy: [AuthorOrderByWithRelationInput!], skip: Int, take: Int, where: AuthorWhereInput): Author
  findFirstBook(cursor: BookWhereUniqueInput, distinct: [BookScalarFieldEnum!], orderBy: [BookOrderByWithRelationInput!], skip: Int, take: Int, where: BookWhereInput): Book
  findFirstBookOrThrow(cursor: BookWhereUniqueInput, distinct: [BookScalarFieldEnum!], orderBy: [BookOrderByWithRelationInput!], skip: Int, take: Int, where: BookWhereInput): Book
  findFirstCategoriesOnBooks(cursor: CategoriesOnBooksWhereUniqueInput, distinct: [CategoriesOnBooksScalarFieldEnum!], orderBy: [CategoriesOnBooksOrderByWithRelationInput!], skip: Int, take: Int, where: CategoriesOnBooksWhereInput): CategoriesOnBooks
  findFirstCategoriesOnBooksOrThrow(cursor: CategoriesOnBooksWhereUniqueInput, distinct: [CategoriesOnBooksScalarFieldEnum!], orderBy: [CategoriesOnBooksOrderByWithRelationInput!], skip: Int, take: Int, where: CategoriesOnBooksWhereInput): CategoriesOnBooks
  findFirstCategory(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstCategoryOrThrow(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findManyCategoriesOnBooks(cursor: CategoriesOnBooksWhereUniqueInput, distinct: [CategoriesOnBooksScalarFieldEnum!], orderBy: [CategoriesOnBooksOrderByWithRelationInput!], skip: Int, take: Int, where: CategoriesOnBooksWhereInput): [CategoriesOnBooks!]!
  findUniqueCategoriesOnBooks(where: CategoriesOnBooksWhereUniqueInput!): CategoriesOnBooks
  findUniqueCategoriesOnBooksOrThrow(where: CategoriesOnBooksWhereUniqueInput!): CategoriesOnBooks
  getAuthor(where: AuthorWhereUniqueInput!): Author
  getBook(where: BookWhereUniqueInput!): Book
  getCategory(where: CategoryWhereUniqueInput!): Category
  getUser(where: UserWhereUniqueInput!): User
  groupByAuthor(by: [AuthorScalarFieldEnum!]!, having: AuthorScalarWhereWithAggregatesInput, orderBy: [AuthorOrderByWithAggregationInput!], skip: Int, take: Int, where: AuthorWhereInput): [AuthorGroupBy!]!
  groupByBook(by: [BookScalarFieldEnum!]!, having: BookScalarWhereWithAggregatesInput, orderBy: [BookOrderByWithAggregationInput!], skip: Int, take: Int, where: BookWhereInput): [BookGroupBy!]!
  groupByCategoriesOnBooks(by: [CategoriesOnBooksScalarFieldEnum!]!, having: CategoriesOnBooksScalarWhereWithAggregatesInput, orderBy: [CategoriesOnBooksOrderByWithAggregationInput!], skip: Int, take: Int, where: CategoriesOnBooksWhereInput): [CategoriesOnBooksGroupBy!]!
  groupByCategory(by: [CategoryScalarFieldEnum!]!, having: CategoryScalarWhereWithAggregatesInput, orderBy: [CategoryOrderByWithAggregationInput!], skip: Int, take: Int, where: CategoryWhereInput): [CategoryGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum Role {
  admin
  editor
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  created_at: DateTime
  email: String!
  favoriteBookByAuthor: Book
  id: Int!
  password: String!
  role: Role!
  updated_at: DateTime
  user_name: String!
}

type UserAvgAggregate {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserCountAggregate {
  _all: Int!
  created_at: Int!
  email: Int!
  id: Int!
  password: Int!
  role: Int!
  updated_at: Int!
  user_name: Int!
}

input UserCountOrderByAggregateInput {
  created_at: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  role: SortOrder
  updated_at: SortOrder
  user_name: SortOrder
}

input UserCreateInput {
  created_at: DateTime
  email: String!
  password: String!
  role: Role
  updated_at: DateTime
  user_name: String!
}

input UserCreateManyInput {
  created_at: DateTime
  email: String!
  id: Int
  password: String!
  role: Role
  updated_at: DateTime
  user_name: String!
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  created_at: DateTime
  email: String!
  id: Int!
  password: String!
  role: Role!
  updated_at: DateTime
  user_name: String!
}

type UserMaxAggregate {
  created_at: DateTime
  email: String
  id: Int
  password: String
  role: Role
  updated_at: DateTime
  user_name: String
}

input UserMaxOrderByAggregateInput {
  created_at: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  role: SortOrder
  updated_at: SortOrder
  user_name: SortOrder
}

type UserMinAggregate {
  created_at: DateTime
  email: String
  id: Int
  password: String
  role: Role
  updated_at: DateTime
  user_name: String
}

input UserMinOrderByAggregateInput {
  created_at: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  role: SortOrder
  updated_at: SortOrder
  user_name: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  created_at: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  role: SortOrder
  updated_at: SortOrder
  user_name: SortOrder
}

input UserOrderByWithRelationInput {
  created_at: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  role: SortOrder
  updated_at: SortOrder
  user_name: SortOrder
}

enum UserScalarFieldEnum {
  created_at
  email
  id
  password
  role
  updated_at
  user_name
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  created_at: DateTimeNullableWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  password: StringWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
  updated_at: DateTimeNullableWithAggregatesFilter
  user_name: StringWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUpdateInput {
  created_at: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
  user_name: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  created_at: NullableDateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updated_at: NullableDateTimeFieldUpdateOperationsInput
  user_name: StringFieldUpdateOperationsInput
}

input UserUser_nameEmailCompoundUniqueInput {
  email: String!
  user_name: String!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  created_at: DateTimeNullableFilter
  email: StringFilter
  id: IntFilter
  password: StringFilter
  role: EnumRoleFilter
  updated_at: DateTimeNullableFilter
  user_name: StringFilter
}

input UserWhereUniqueInput {
  id: Int
  user_name_email: UserUser_nameEmailCompoundUniqueInput
}
